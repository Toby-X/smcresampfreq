a = rep(0,n)
nw = n*w
intpart = floor(nw)
sip = sum(intpart)
res = nw - intpart
sres = n - sip
a[1:sip] = rep(1:n,intpart)
if (sres > 0){
a[(sip+1):n] = sample(res/sres,sres)
}
return(a)
}
a = rep(1/5,5)
resresample(a)
path1 = file.choose()
mixture.dat = read.table(path1,header=TRUE)
y = mixture.dat$y
## libraries
library(Boom)
## Given Value
n = 500
p = 50
mu = array(rep(0,n*p*2),c(n,p,2))# the first layer is mu1, the second layer is mu2, the same is as follows
lambda = array(rep(0,n*p*2),c(n,p,2))
omega = array(rep(0,n*p*2),c(n,p,2))
wu = rep(0,n)
threshold = n
# prior choices from Richardson and Green P735
kexi = mean(y)
R = max(y)-min(y)
K = 1/R^2
set.seed(101)
beta = rgamma(1,0.2,10/R^2)
alpha = 2
delta = 1
#using residual ressampling
resresample <- function(w){
n = length(w)
a = rep(0,n)
nw = n*w
intpart = floor(nw)
sip = sum(intpart)
res = nw - intpart
sres = n - sip
a[1:sip] = rep(1:n,intpart)
if (sres > 0){
a[(sip+1):n] = sample(res/sres,sres)
}
return(a)
}
##the data is generated from .7*dnorm(x,7,.5) + .3*dnorm(x,10,.5)
## pin is proportional to likelihood(y;theta_r)^phi_n * f(theta_r)
## update mu via additive normal random-walk proposal
## lambda via multiplicative log-normal random-walk
## omega via additive normal random-walk
log.likelihood <- function(mu,lambda,omega){
sum(log(omega[1]*dnorm(y,mu[1],lambda^(-1/2))+omega[2]*dnorm(y,mu[2],lambda^(-1/2))))
}
## using one iteration of MH kernel
## using first 50 steps of annealing
## using dnorm(0,1) as proposal in initial state and in MCMC
phi <- function(n){
if (n<=10){
return(n*0.01/10)
}else{
r = (1/0.01)^(1/40)
return(0.01*r^(n-10))
}
}
log.fn <- function(n,mu,lambda,omega){
res = log.likelihood(mu,lambda,omega)*phi(n)+sum(log(dnorm(mu,kexi,K^(-1/2))))+
sum(log(dgamma(lambda,alpha,beta)))+sum(log(ddirichlet(omega,c(delta,delta))))
return(res)
}
## 这里lognormal multiplicative还要再推导一下，现在是推导出来的结果
acceptance <- function(n,mu,lambda,omega,mut,lambdat,omegat){
u = exp(omega[1])/(1+exp(omega[1]))
ut = exp(omegat[1])/(1+exp(omegat[1]))
log.res = log.fn(n,mu,lambda,omega)-log.fn(n,mut,lambdat,omegat)+
log(omegat[1]*(1-omegat[1])/(omega[1]*(1-omega[1])))+
sum(log(lambda)-log(lambdat))
res = exp(log.res)
return(min(res,1))
}
acceptance.mu <- function(n,mu,lambda,omega,mut,lambdat,omegat){
log.res = log.fn(n,mu,lambda,omega)-log.fn(n,mut,lambdat,omegat)
res = exp(log.res)
return(min(res,1))
}
acceptance.lambda1 <- function(n,mu,lambda,omega,mut,lambdat,omegat){
log.res = log.fn(n,mu,lambda,omega)-log.fn(n,mut,lambdat,omegat)+log(lambda[1])-log(lambdat[1])
res = exp(log.res)
return(min(res,1))
}
acceptance.lambda2 <- function(n,mu,lambda,omega,mut,lambdat,omegat){
log.res = log.fn(n,mu,lambda,omega)-log.fn(n,mut,lambdat,omegat)+log(lambda[2])-log(lambdat[2])
res = exp(log.res)
return(min(res,1))
}
acceptance.omega <- function(n,mu,lambda,omega,mut,lambdat,omegat){
u = exp(omega[1])/(1+exp(omega[1]))
ut = exp(omegat[1])/(1+exp(omegat[1]))
log.res = log.fn(n,mu,lambda,omega)-log.fn(n,mut,lambdat,omegat)+
log(omegat[1]*(1-omegat[1])/(omega[1]*(1-omega[1])))
res = exp(log.res)
return(min(res,1))
}
## Next step is to write the whole process including weight
Kn <- function(mu,lambda,omega,mut,lambdat,omegat){
u = exp(omega[1])/(1+exp(omega[1]))
ut = exp(omegat[1])/(1+exp(omegat[1]))
res = sum(log(dnorm(mu-mut,0,.1)))+sum(log(dlnorm(lambda/lambdat,0,.1)))+
log(dnorm(u-ut,0,.1))-log(omega[1])-log(1-omega[1])
res = exp(res)
return(res)
}
## Using suboptimal backward kernels
## extract the first sample
for (i in 1:n){
mu[i,1,] = rnorm(2,kexi,K^(-1/2))
lambda[i,1,] = rgamma(2,alpha,beta)
omega[i,1,] = rdirichlet(1,c(delta,delta))
}
## estimate weights for step 1
w_u = rep(1,n)
for (i in 1:n) {
w_u[i] = exp(log.fn(1,mu[i,1,],lambda[i,1,],omega[i,1,]))/prod(dnorm(mu[i,1,],kexi,K^(-1/2)))/prod(dgamma(lambda[i,1,],alpha,beta))/ddirichlet(omega[i,1,],c(delta,delta))
}
if (any(is.na(w_u))){
idx.na = is.na(w_u)
w_u[idx.na]=0
}
w_n = w_u/sum(w_u)
if (1/sum(w_n^2) < threshold){
idx = resresample(w_n)
lambda = lambda[idx,,]
mu = mu[idx,,]
omega = omega[idx,,]
w_n = rep(1/n,n)
}
##monitor accepted times
ac.mu = array(rep(0,n*p),c(n,p))
ac.lambda = array(rep(0,n*p*2),c(n,p,2))
ac.omega = array(rep(0,n*p),c(n,p))
## MAIN LOOP
star_time <- Sys.time()
w_u.tmp = rep(1,n)
i = 2
## MCMC Move
mu.update = array(rnorm(n*2,0,.1),c(n,2))
mu.tmp = mu[,i-1,]+mu.update
str(mu[,i-1,])
str(mu.update)
## Using suboptimal backward kernels
## extract the first sample
for (i in 1:n){
mu[i,1,] = rnorm(2,kexi,K^(-1/2))
lambda[i,1,] = rgamma(2,alpha,beta)
omega[i,1,] = rdirichlet(1,c(delta,delta))
}
mu = array(rep(0,n*p*2),c(n,p,2))# the first layer is mu1, the second layer is mu2, the same is as follows
lambda = array(rep(0,n*p*2),c(n,p,2))
omega = array(rep(0,n*p*2),c(n,p,2))
wu = rep(0,n)
## Using suboptimal backward kernels
## extract the first sample
for (i in 1:n){
mu[i,1,] = rnorm(2,kexi,K^(-1/2))
lambda[i,1,] = rgamma(2,alpha,beta)
omega[i,1,] = rdirichlet(1,c(delta,delta))
}
## estimate weights for step 1
w_u = rep(1,n)
for (i in 1:n) {
w_u[i] = exp(log.fn(1,mu[i,1,],lambda[i,1,],omega[i,1,]))/prod(dnorm(mu[i,1,],kexi,K^(-1/2)))/prod(dgamma(lambda[i,1,],alpha,beta))/ddirichlet(omega[i,1,],c(delta,delta))
}
if (any(is.na(w_u))){
idx.na = is.na(w_u)
w_u[idx.na]=0
}
w_n = w_u/sum(w_u)
w_n
w = w_n
w
n = length(w)
n
a = rep(0,n)
nw = n*w
intpart = floor(nw)
sip = sum(intpart)
sip
res = nw - intpart
sres = n - sip
sres
a[1:sip] = rep(1:n,intpart)
a[1:sip]
a[sip+1]
res
sres
if (sres > 0){
a[(sip+1):n] = sample(1:n,sres,prob=res/sres)
}
a[(sip+1):n]
#using residual ressampling
resresample <- function(w){
n = length(w)
a = rep(0,n)
nw = n*w
intpart = floor(nw)
sip = sum(intpart)
res = nw - intpart
sres = n - sip
a[1:sip] = rep(1:n,intpart)
if (sres > 0){
a[(sip+1):n] = sample(1:n,sres,prob=res/sres)
}
return(a)
}
if (1/sum(w_n^2) < threshold){
idx = resresample(w_n)
lambda = lambda[idx,,]
mu = mu[idx,,]
omega = omega[idx,,]
w_n = rep(1/n,n)
}
##monitor accepted times
ac.mu = array(rep(0,n*p),c(n,p))
ac.lambda = array(rep(0,n*p*2),c(n,p,2))
ac.omega = array(rep(0,n*p),c(n,p))
## MAIN LOOP
star_time <- Sys.time()
w_u.tmp = rep(1,n)
i= 2
## MCMC Move
mu.update = array(rnorm(n*2,0,.1),c(n,2))
mu.tmp = mu[,i-1,]+mu.update
lambda.update = array(rlnorm(n*2,0,.1),c(n,2))
?var
setwd("C:/Users/xuzhi/smcresampfreq/Gaussian Mixture/MulResamp")
load("p50MCMC1mul1.RData")
load("p50MCMC1mul.RData")
head(res)
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
head(omega7)
apply(mu7,2,var)
head(lambda)
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(mse.mu)
plot(mse.omega)
plot(mse.lambda)
boxplot(mu7)
a = which.max(mu7[,6])
b = which.max(mu7[,8])
mu7 = mu7[c(-a,-b),]
mu10 = mu10[c(-a,-b),]
omega7 = omega7[c(-a,-b),]
lambda = lambda[c(-a,-b),]
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(mse.mu)
plot(mse.omega)
plot(mse.lambda)
plot(threshold,mse.mu,xlab = "ESS Threshold")
plot(threshold,mse.omega, xlab = "ESS Threshold")
plot(threshold,mse.lambda, xlab = "ESS Threshold")
boxplot(mu7)
load("p100MCMC1mul.RData")
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
head(res)
head(mu7)
load("p100MCMC1mul.RData")
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
?order
a = order(mu7[,8],decreasing = T)
b = which.min(mu7[,9])
mu7 = mu7[c(-a[1:2],-b),]
mu10 = mu10[c(-a[1:2],-b),]
omega7 = omega7[c(-a[1:2],-b),]
lambda = lambda[c(-a[1:2],-b),]
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(threshold,mse.mu,xlab = "ESS Threshold")
plot(threshold,mse.omega, xlab = "ESS Threshold")
plot(threshold,mse.lambda, xlab = "ESS Threshold")
setwd("C:/Users/xuzhi/smcresampfreq/Gaussian Mixture/SysResamp")
load("p50MCMC1sys.RData")
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
a = order(mu7[,9],decreasing = T)
b = which.max(mu7[,5])
mu7 = mu7[c(-a[1:2],-b),]
mu10 = mu10[c(-a[1:2],-b),]
omega7 = omega7[c(-a[1:2],-b),]
lambda = lambda[c(-a[1:2],-b),]
boxplot(mu7)
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
a = order(mu7[,9],decreasing = T)
b = which.max(mu7[,5])
c = which.min(mu7[,4])
mu7 = mu7[c(-a[1:2],-b,-c),]
mu10 = mu10[c(-a[1:2],-b,-c),]
omega7 = omega7[c(-a[1:2],-b,-c),]
lambda = lambda[c(-a[1:2],-b,-c),]
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(threshold,mse.mu,xlab = "ESS Threshold")
plot(threshold,mse.omega, xlab = "ESS Threshold")
plot(threshold,mse.lambda, xlab = "ESS Threshold")
load("p100MCMC1sys.RData")
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
a = which.min(mu7[,3])
function (x, ...)
# b = which.max(mu7[,8])
mu7 = mu7[c(-a),]
mu10 = mu10[c(-a),]
omega7 = omega7[c(-a),]
lambda = lambda[c(-a),]
boxplot(mu7)
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
a = which.min(mu7[,3])
# b = which.max(mu7[,8])
mu7 = mu7[c(-a),]
mu10 = mu10[c(-a),]
omega7 = omega7[c(-a),]
lambda = lambda[c(-a),]
boxplot(mu7)
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(threshold,mse.mu,xlab = "ESS Threshold")
plot(threshold,mse.omega, xlab = "ESS Threshold")
plot(threshold,mse.lambda, xlab = "ESS Threshold")
setwd("C:/Users/xuzhi/smcresampfreq/Gaussian Mixture/ResResamp")
load("p50MCMC1res.RData")
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
# b = which.max(mu7[,8])
mu7 = mu7[c(-a,),]
mu10 = mu10[c(-a,),]
omega7 = omega7[c(-a,),]
lambda = lambda[c(-a,),]
a = which.max(mu7[,6])
# b = which.max(mu7[,8])
mu7 = mu7[c(-a,),]
# b = which.max(mu7[,8])
mu7 = mu7[c(-a),]
mu10 = mu10[c(-a),]
omega7 = omega7[c(-a),]
lambda = lambda[c(-a),]
boxplot(mu7)
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(threshold,mse.mu,xlab = "ESS Threshold")
plot(threshold,mse.omega, xlab = "ESS Threshold")
plot(threshold,mse.lambda, xlab = "ESS Threshold")
load("p100MCMC1res.RData")
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
mu7 = mu7[c(-a),]
mu10 = mu10[c(-a),]
omega7 = omega7[c(-a),]
lambda = lambda[c(-a),]
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
boxplot(mu7)
boxplot(mu7)
mu7 = matrix(rep(0,m*length(threshold)),nrow=m)
mu10 = matrix(rep(0,m*length(threshold)),nrow = m)
omega7 = matrix(rep(0,m*length(threshold)),nrow = m)
lambda = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m){
mu7[i,] = res[i,]$mu7
mu10[i,] = res[i,]$mu10
lambda[i,] = res[i,]$lambda
omega7[i,] = res[i,]$omega7
}
boxplot(mu7)
a = which.max(mu7[,2])
mu7 = mu7[c(-a),]
mu10 = mu10[c(-a),]
omega7 = omega7[c(-a),]
lambda = lambda[c(-a),]
boxplot(mu7)
mse.mu = (colMeans(mu7)-7)^2+apply(mu7,2,var)+(colMeans(mu10)-10)^2+apply(mu10,2,var)
mse.omega = (colMeans(omega7)-0.7)^2+apply(omega7,2,var)
mse.lambda = (colMeans(lambda)-4)^2+apply(lambda,2,var)
plot(threshold,mse.mu,xlab = "ESS Threshold")
plot(threshold,mse.omega, xlab = "ESS Threshold")
plot(threshold,mse.lambda, xlab = "ESS Threshold")
1e-20
1e-50
1e-80
3.2*1e-80
##INITIAL VALUES
t = 50##dimension
n = 500##number of particles
N = 1e6
m = 500##first parallel to yield mse
p = 192## parallel experiments
alpha=0.91
sigma=1.0
beta=0.5
W=rep(1,n)/n
threshold = seq(.1,1,by=0.1)
1e-301
3.2*1e-301*54*1e-865
1e-865
1e-500
1e-300
1e-400
1e-311
1e-312
1e-313
1e-350
1e-320
1e-321
1e-322
1e-323
1e400
