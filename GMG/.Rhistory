## extract the first sample
for (i in 1:n){
mu[i,1,] = rnorm(2,kexi,K^(-1/2))
lambda[i,1,] = rgamma(2,alpha,beta)
omega[i,1,] = rdirichlet(1,c(delta,delta))
}
## estimate weights for step 1
w_u = rep(1,n)
for (i in 1:n) {
w_u[i] = exp(log.fn(1,mu[i,1,],lambda[i,1,],omega[i,1,]))/prod(dnorm(mu[i,1,],kexi,K^(-1/2)))/prod(dgamma(lambda[i,1,],alpha,beta))/ddirichlet(omega[i,1,],c(delta,delta))
}
if (any(is.na(w_u))){
idx.na = is.na(w_u)
w_u[idx.na]=0
}
w_n = w_u/sum(w_u)
w_n
w = w_n
w
n = length(w)
n
a = rep(0,n)
nw = n*w
intpart = floor(nw)
sip = sum(intpart)
sip
res = nw - intpart
sres = n - sip
sres
a[1:sip] = rep(1:n,intpart)
a[1:sip]
a[sip+1]
res
sres
if (sres > 0){
a[(sip+1):n] = sample(1:n,sres,prob=res/sres)
}
a[(sip+1):n]
#using residual ressampling
resresample <- function(w){
n = length(w)
a = rep(0,n)
nw = n*w
intpart = floor(nw)
sip = sum(intpart)
res = nw - intpart
sres = n - sip
a[1:sip] = rep(1:n,intpart)
if (sres > 0){
a[(sip+1):n] = sample(1:n,sres,prob=res/sres)
}
return(a)
}
if (1/sum(w_n^2) < threshold){
idx = resresample(w_n)
lambda = lambda[idx,,]
mu = mu[idx,,]
omega = omega[idx,,]
w_n = rep(1/n,n)
}
##monitor accepted times
ac.mu = array(rep(0,n*p),c(n,p))
ac.lambda = array(rep(0,n*p*2),c(n,p,2))
ac.omega = array(rep(0,n*p),c(n,p))
## MAIN LOOP
star_time <- Sys.time()
w_u.tmp = rep(1,n)
i= 2
## MCMC Move
mu.update = array(rnorm(n*2,0,.1),c(n,2))
mu.tmp = mu[,i-1,]+mu.update
lambda.update = array(rlnorm(n*2,0,.1),c(n,2))
?var
t = 50##dimension
n = 500##number of particles
N = 1e6
m = 200##first parallel to yield mse
p = 192## parallel experiments
alpha=0.91
sigma=1.0
beta=0.5
W=rep(1,n)/n
threshold = seq(.1,1,by=0.1)
x = rep(0,t)
y = rep(0,t)
X = matrix(rep(0,n*t),nrow=n)
X0 = matrix(rep(0,N*t),nrow=N)
x.estimate.ss = array(rep(0,t*m*length(threshold)),c(m,t,length(threshold)))
x.estimate.ori = rep(0,t)
set.seed(l)
##Generate Samples
v = rnorm(t)
u = rnorm(t)
x[1] = rnorm(1,0,sigma^2/(1-alpha^2))
y[1] = beta*exp(x[1]/2)*u[1]
for (i in 2:t){
x[i] = alpha*x[i-1]+sigma*v[i]
y[i] = beta*exp(x[i]/2)*u[i]
}
j = 1
X[,1] = rnorm(n)
W = dnorm(X[,1],0,sigma^2/(1-alpha^2))*dnorm(y[i],0,beta*exp(X[,i]/2))/dnorm(X[,1])
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,1,j] = sum(w*X[,1])
l = 1
x.estimate.ss[l,1,j] = sum(w*X[,1])
if (1/sum(w^2) < threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
for (i in 2:t) {
X[,i]=rnorm(n,X[,i-1]+y[i])
lW.tmp = log(dnorm(X[,i],alpha*X[,i-1],sigma^2))+log(dnorm(y[i],0,beta*exp(X[,i]/2)))-log(dnorm(X[,i],X[,i-1]+y[i]))
if (all(lW.tmp<log(1e-200))){
lW.tmp = lW.tmp + log(1e300)
}
if (all(exp(lW.tmp)==0)){
cat("i=",i)
}
W = W*exp(lW.tmp)
if (all(W<1e-50)){
W = W*1e100
}
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,i,j] = sum(w*X[,i])
if (1/sum(w^2)<threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
}
W
plot(x)
l = 2
##Generate Samples
v = rnorm(t)
u = rnorm(t)
x[1] = rnorm(1,0,sigma^2/(1-alpha^2))
y[1] = beta*exp(x[1]/2)*u[1]
for (i in 2:t){
x[i] = alpha*x[i-1]+sigma*v[i]
y[i] = beta*exp(x[i]/2)*u[i]
}
X[,1] = rnorm(n)
W = dnorm(X[,1],0,sigma^2/(1-alpha^2))*dnorm(y[i],0,beta*exp(X[,i]/2))/dnorm(X[,1])
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,1,j] = sum(w*X[,1])
if (1/sum(w^2) < threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
for (i in 2:t) {
X[,i]=rnorm(n,X[,i-1]+y[i])
lW.tmp = log(dnorm(X[,i],alpha*X[,i-1],sigma^2))+log(dnorm(y[i],0,beta*exp(X[,i]/2)))-log(dnorm(X[,i],X[,i-1]+y[i]))
if (all(lW.tmp<log(1e-200))){
lW.tmp = lW.tmp + log(1e300)
}
if (all(exp(lW.tmp)==0)){
cat("i=",i)
}
W = W*exp(lW.tmp)
if (all(W<1e-50)){
W = W*1e100
}
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,i,j] = sum(w*X[,i])
if (1/sum(w^2)<threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
}
plot(x.estimate.ss[2,,])
plot(x.estimate.ss[2,,1])
l = 3
##Generate Samples
v = rnorm(t)
u = rnorm(t)
x[1] = rnorm(1,0,sigma^2/(1-alpha^2))
y[1] = beta*exp(x[1]/2)*u[1]
for (i in 2:t){
x[i] = alpha*x[i-1]+sigma*v[i]
y[i] = beta*exp(x[i]/2)*u[i]
}
X[,1] = rnorm(n)
W = dnorm(X[,1],0,sigma^2/(1-alpha^2))*dnorm(y[i],0,beta*exp(X[,i]/2))/dnorm(X[,1])
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,1,j] = sum(w*X[,1])
if (1/sum(w^2) < threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
for (i in 2:t) {
X[,i]=rnorm(n,X[,i-1]+y[i])
lW.tmp = log(dnorm(X[,i],alpha*X[,i-1],sigma^2))+log(dnorm(y[i],0,beta*exp(X[,i]/2)))-log(dnorm(X[,i],X[,i-1]+y[i]))
if (all(lW.tmp<log(1e-200))){
lW.tmp = lW.tmp + log(1e300)
}
if (all(exp(lW.tmp)==0)){
cat("i=",i)
}
W = W*exp(lW.tmp)
if (all(W<1e-50)){
W = W*1e100
}
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,i,j] = sum(w*X[,i])
if (1/sum(w^2)<threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
}
l = 4
set.seed(l)
##Generate Samples
v = rnorm(t)
u = rnorm(t)
x[1] = rnorm(1,0,sigma^2/(1-alpha^2))
y[1] = beta*exp(x[1]/2)*u[1]
for (i in 2:t){
x[i] = alpha*x[i-1]+sigma*v[i]
y[i] = beta*exp(x[i]/2)*u[i]
}
X[,1] = rnorm(n)
W = dnorm(X[,1],0,sigma^2/(1-alpha^2))*dnorm(y[i],0,beta*exp(X[,i]/2))/dnorm(X[,1])
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,1,j] = sum(w*X[,1])
if (1/sum(w^2) < threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
for (i in 2:t) {
X[,i]=rnorm(n,X[,i-1]+y[i])
lW.tmp = log(dnorm(X[,i],alpha*X[,i-1],sigma^2))+log(dnorm(y[i],0,beta*exp(X[,i]/2)))-log(dnorm(X[,i],X[,i-1]+y[i]))
if (all(lW.tmp<log(1e-200))){
lW.tmp = lW.tmp + log(1e300)
}
if (all(exp(lW.tmp)==0)){
cat("i=",i)
}
W = W*exp(lW.tmp)
if (all(W<1e-50)){
W = W*1e100
}
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,i,j] = sum(w*X[,i])
if (1/sum(w^2)<threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
}
#-*- coding:utf-8 -*-
library(parallel)
library(foreach)
library(doSNOW)
numCores = detectCores()
cl = makeCluster(numCores)
registerDoSNOW(cl)
m = 192
## doSNOW progress bar
pb = txtProgressBar(max = m,style=3)
progress = function(n) setTxtProgressBar(pb,n)
opts = list(progress=progress)
##INITIAL VALUES
t = 50##dimension
n = 500##number of particles
m = 200##first parallel to yield mse
p = 48## parallel experiments
alpha=0.91
sigma=1.0
beta=0.5
W=rep(1,n)/n
threshold = seq(.1,1,by=0.1)
doit <- function(l){
x = rep(0,t)
y = rep(0,t)
X = matrix(rep(0,n*t),nrow=n)
X0 = matrix(rep(0,N*t),nrow=N)
x.estimate.ss = array(rep(0,t*m*length(threshold)),c(m,t,length(threshold)))
x.estimate.ori = rep(0,t)
set.seed(l)
##Generate Samples
v = rnorm(t)
u = rnorm(t)
x[1] = rnorm(1,0,sigma^2/(1-alpha^2))
y[1] = beta*exp(x[1]/2)*u[1]
for (i in 2:t){
x[i] = alpha*x[i-1]+sigma*v[i]
y[i] = beta*exp(x[i]/2)*u[i]
}
for (l in 1:m) {
for (j in 1:length(threshold)){#change of series
X[,1] = rnorm(n)
W = dnorm(X[,1],0,sigma^2/(1-alpha^2))*dnorm(y[i],0,beta*exp(X[,i]/2))/dnorm(X[,1])
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,1,j] = sum(w*X[,1])
if (1/sum(w^2) < threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
for (i in 2:t) {
X[,i]=rnorm(n,X[,i-1]+y[i])
lW.tmp = log(dnorm(X[,i],alpha*X[,i-1],sigma^2))+log(dnorm(y[i],0,beta*exp(X[,i]/2)))-log(dnorm(X[,i],X[,i-1]+y[i]))
if (all(lW.tmp<log(1e-200))){
lW.tmp = lW.tmp + log(1e300)
}
if (all(exp(lW.tmp)==0)){
cat("i=",i)
}
W = W*exp(lW.tmp)
if (all(W<1e-50)){
W = W*1e100
}
if (any(is.na(W))){
idx = is.na(W)
W[idx] = 0
}
w = W/sum(W)
x.estimate.ss[l,i,j] = sum(w*X[,i])
if (1/sum(w^2)<threshold[j]*n){
idx = sample(1:n,n,prob = w, replace = T)
X = X[idx,]
W = rep(1/n,n)
}
}
}
}
mse.ss <- matrix(rep(0,length(threshold)*t),nrow=length(threshold))
for (k in 1:length(threshold)){
for (i in 1:m)
{
mse.ss[k,] = mse.ss[k,]+(x-x.estimate.ss[i,,k])^2
}
}
mse.ss = mse.ss/m
mse.sum.ss <- rowSums(mse.ss)
return(list(mse = mse.sum.ss, x.estimate=x.estimate.ss, x=x))
}
res = foreach (l = 1:p,.combine = rbind,.packages = "Boom",
.options.snow=opts) %dopar% {
return(doit(l))
}
gc()
gc()
gc()
infty
inf
+inf
Inf
-Inf
0>-Inf
is.na(Inf)
is.infinite(Inf)
is.infinite(0)
log(1e200)
log(1e-200)
1e-312
-Inf+200
setwd("C:/Users/xuzhi/smcresampfreq/HD")
load("HDR.RData")
X = array(rep(0,m*p*length(threshold)),c(m,p,length(threshold)))
rejuvs = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m) {
X[i,,] = res[i,]$estimate
rejuvs[i,] = res[i,]$rejuvs
}
colMeans(rejuvs)
mse = rep(0,length(threshold))
for (j in 1:length(threshold)) {
mse[j] = sum(X[,,j]^2)
}
ess = seq(.1,1,by=.1)
plot(ess,mse,ylab = "MSE",xlab = "ESS Threshold")
load("HDS.RData")
X = array(rep(0,m*p*length(threshold)),c(m,p,length(threshold)))
rejuvs = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m) {
X[i,,] = res[i,]$estimate
rejuvs[i,] = res[i,]$rejuvs
}
colMeans(rejuvs)
mse = rep(0,length(threshold))
for (j in 1:length(threshold)) {
mse[j] = sum(X[,,j]^2)
}
mse = mse/m
plot(ess,mse,xlab="ESS Threshold",ylab="MSE")
load("HDM.RData")
X = array(rep(0,m*p*length(threshold)),c(m,p,length(threshold)))
rejuvs = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m) {
X[i,,] = res[i,]$estimate
rejuvs[i,] = res[i,]$rejuvs
}
colMeans(rejuvs)
mse = rep(0,length(threshold))
for (j in 1:length(threshold)) {
mse[j] = sum(X[,,j]^2)
}
mse = mse/m
plot(ess,mse,xlab="ESS Threshold",ylab="MSE")
load("HDM1.RData")
X = array(rep(0,m*p*length(threshold)),c(m,p,length(threshold)))
rejuvs = matrix(rep(0,m*length(threshold)),nrow = m)
for (i in 1:m) {
X[i,,] = res[i,]$estimate
rejuvs[i,] = res[i,]$rejuvs
}
colMeans(rejuvs)
mse = rep(0,length(threshold))
for (j in 1:length(threshold)) {
mse[j] = sum(X[,,j]^2)
}
mse = mse/m
plot(ess,mse,xlab="ESS Threshold",ylab="MSE")
setwd("C:/Users/xuzhi/smcresampfreq/Stochastic Votality")
load("SVSO2.RData")
mse = matrix(rep(0,p*length(threshold)),nrow=p)
rejuvs = matrix(rep(0,p*length(threshold)),nrow=p)
for (i in 1:p) {
mse[i,] = res[i,]$mse
rejuvs[i,] = res[i,]$rejuvs
}
mse.mean = colMeans(mse)
rejuvs.mean = colMeans(rejuvs)
plot(ess, mse.mean,ylab="MSE",xlab="ESS Threshold")
load("SVSO3.RData")
mse = matrix(rep(0,p*length(threshold)),nrow=p)
rejuvs = matrix(rep(0,p*length(threshold)),nrow=p)
for (i in 1:p) {
mse[i,] = res[i,]$mse
rejuvs[i,] = res[i,]$rejuvs
}
mse.mean = colMeans(mse)
rejuvs.mean = colMeans(rejuvs)
ess = seq(0.1,1,by=.1)
plot(ess, mse.mean,ylab="MSE",xlab="ESS Threshold")
setwd("C:/Users/xuzhi/smcresampfreq/GMG")
load("GMGM.RData")
X = array(rep(0,m*n_dim*length(threshold)),c(m,n_dim,length(threshold)))
rejuvs = matrix(rep(0,m*length(threshold)),nrow=m)
for (i in 1:m){
X[i,,] = t(res[i,]$estimate)
rejuvs[i,] = res[i,]$rejuvs
}
colMeans(rejuvs)
plot(X[,19,1],X[,20,1])
mse = rep(0,length(threshold))
for (j in 1:length(threshold)) {
mse[j] = sum(X[,,j]^2)
}
mse = mse/m
plot(ess,mse,xlab="ESS Threshold",ylab="MSE")
load("GMGS.RData")
X = array(rep(0,m*n_dim*length(threshold)),c(m,n_dim,length(threshold)))
rejuvs = matrix(rep(0,m*length(threshold)),nrow=m)
for (i in 1:m){
X[i,,] = t(res[i,]$estimate)
rejuvs[i,] = res[i,]$rejuvs
}
colMeans(rejuvs)
plot(X[,19,1],X[,20,1])
mse = rep(0,length(threshold))
for (j in 1:length(threshold)) {
mse[j] = sum(X[,,j]^2)
}
mse = mse/m
plot(mse)
plot(ess,mse,xlab="ESS Threshold",ylab="MSE")
